# PLC / SCADA 学習用シミュレータ 技術資料 (Technical Reference)

本資料は、本リポジトリのシステム構造および、YAML設定ファイルの記述仕様を解説したドキュメントです。

## 1. システム概要

本システムは「制御ロジック」「物理デバイス」「管理監視」を分離したマルチプロセス構成です。

* **Orchestrator**: プロセスの司令塔。依存関係解決、死活監視、CLIを通じた障害注入。
* **PLC Simulator**: ロジック演算。Larkパーサーによるラダー実行とModbusサーバー。
* **Device Simulator**: 物理挙動の模倣。ModbusクライアントとしてPLCのI/Oを操作。
* **IODevice**: PLC間またはPLC-外部システム間のデータ中継（ブリッジ）。


## 2. PLC 仕様詳細

### 2.1 メモリモデルと Modbus アドレスマップ

PLC内部メモリは、`modbus_server.py` 内の定義に基づき、以下の通り Modbus アドレスにマッピングされます。

**Coil領域は Y と M で共有されており、M は干渉防止のためオフセット（1000〜）を持って配置されます。**

本シミュレータでは、シミュレータとしての利便性を高めるために、標準のModbus仕様(DIはReadOnly)を拡張した「SIM_INJECT」機能を搭載しました。
  - SIM_INJECTとは、PLCシミュレータにアタッチするModbus_Serverでの受信処理をフックして、PLCの外部入力（X）の値を更新する機能と捉えてください。

| 種類 | 記号 | Modbus 種別 | アドレス範囲 | 説明 |
| --- | --- | --- | --- | --- |
| **外部入力** | **X** | **Discrete Input** (FC2) | `0` ~ `len(X)-1` | センサー等（Deviceが書込、PLCが読込） **※特殊実装：SIM_INJECT** |
| **外部出力** | **Y** | **Coil** (FC1/FC5) | `0` ~ `len(Y)-1` | アクチュエータ等（PLCが制御） |
| **内部リレー** | **M** | **Coil** (FC1/FC5) | **`1000`** ~ | 内部フラグ。Yとの干渉を防ぐ固定開始地点 |
| **データレジスタ** | **D** | **Holding Reg** (FC3/FC6) | `0` ~ `len(D)-1` | 数値データ（16bit整数） |
| **システム情報** | **SYS** | **Holding Reg** (FC3/FC16) | **`10000`** ~ | PLCの診断情報・カオス設定 |

#### システムレジスタ詳細 (`10000`〜)

SCADAやOrchestratorからPLCの内部状態を監視・制御するための特殊領域です。

| オフセット | 項目名 | 内容 |
| --- | --- | --- |
| `+0` | **Heartbeat** | 0 と 1 が交互に変化（生存確認用） |
| `+1` | **Scan Count** | 起動時からの累計スキャン回数 |
| `+2` | **Uptime** | 起動からの経過時間（秒） |
| `+5` | **Chaos Latency** | **Modbus応答遅延（秒）**。数値を書き込むと即座に反映 |


#### 【重要】入力信号（X）への強制書き込み仕様 (SIM_INJECT)
通常、Modbusプロトコルにおいて Discrete Input (X) は外部（SCADAやDevice）から書き込めませんが、本シミュレータでは以下のロジックでこれを可能にしています。

- **判定:** write_coil リクエストのアドレスが 0〜99 (X領域) の場合、サーバー内部で DI 用のデータブロックを直接書き換える割り込み処理を実行します。
- **用途:** device.py や iodevice.py から、物理的なセンサー入力として PLC に信号を注入するために使用します。

### 2.2 スキャンサイクル

1スキャン（`scan_cycle_ms` ごとに実行）の流れ：

1. **入力同期**: Modbus (Discrete Input) に書き込まれた値を PLC 内部メモリ `X` へ一括コピー。
2. **ロジック評価**: `ladder.yaml` を **Larkパーサー** で解析し、上から順に一行ずつ実行。
3. **タイマー・カウンタ更新**: 前回の実行時間からの差分を計算し、`T` / `C` デバイスの状態を更新。
4. **出力同期**: 内部メモリ `Y`, `M`, `D` および `SYS` 情報を Modbus データストアへ書き戻し。


### 2.3. 設定ファイル（YAML）仕様

#### 2.3.1 PLC 設定 (`plc.yaml`)

CPUの演算性能と、確保するメモリの個数を定義します。Modbus サーバーのサイズはこの個数に従って自動的にリサイズされます。

```yaml
kind: plc              # 固定値
version: "1.0"         # 固定値
name: "plc_conv"       # PLCの名称
log_dir: logs          # ログファイルの出力先
power: true            # 固定値（電源ONを意味します）
cpu:
  scan_cycle_ms: 100   # スキャン周期（小さいほど高速・高負荷）
memory:
  X: 100               # 入力点数 (Modbus DI アドレス 0-99)
  Y: 100               # 出力点数 (Modbus Coil アドレス 0-99)
  M: 1000              # 内部リレー (Modbus Coil アドレス 1000-1999)
  D: 1000              # データレジスタ (Modbus HR アドレス 0-999)
modbus:
  port: 15030          # 外部（Device/SCADA）**が接続するポート**
```

---
## 3. ラダーロジック仕様 (`ladder.yaml`)

本システムは **Larkパーサー** を使用した独自の「テキスト・ラダー言語」を採用しています。

### 3.1 ファイル構造

`ladder.yaml` は、PLCが実行する命令をリスト形式で記述します。

* **順序**: 上から順に実行されます。
* **クォート**: YAMLの構文エラーを防ぐため、各行を **`" "`** で囲んでください。

```yaml
kind: ladder           # 固定値
version: "1.0"         # 固定値
rungs:
  # 1. 加工完了センサー(X10)でプレス開始(M15)を維持。搬送許可(Y0)が出るまで継続。
  - "[ X10 OR M15 ] AND NOT Y0 --(M15)"
  # 2. プレス開始(M15)から3秒後にプレス完了内部信号(M16)をON
  # 書式: [ 条件 ] --(TON タイマー番号 設定ms) --(完了時リレー)
  - "[ M15 ] --(TON T1 3000) --(M16)"
  # 3. プレス完了(M16)したら「搬送許可信号」を外部(Y0)に出力。搬送完了(X1)まで維持。
  - "[ M16 OR Y0 ] AND NOT X1 --(Y0)"
  # 4. ログ記録用
  - "[ X1 ] --(M10)"
  - "END"
```

### 3.2 基本構造と文法ルール

すべての命令は **`[ 条件式 ] --(アクション)`** の形式で記述します。

#### 【重要】記述の必須ルール

1. **スペースの挿入**: トークンを正しく解析するため、**括弧や演算子の前後には必ず半角スペース**を入れてください。
* ✅ `[ X0 AND M0 ]` （正しい）
* ❌ `[X0 AND M0]` （括弧の隙間がないためエラー）

2. **アクション部の密着**: 現在の仕様では、アクション部（右側）の記号 --( と ) の内部にスペースを含めると解析エラーになります。デバイス名は記号と密着させて記述してください。
* ✅ --(Y0)、--(TON T1 3000)
* ❌ -- ( Y0 )、-- (TON T1 3000)


3. **大文字の使用**: デバイス名（`X, Y, M, D, T, C`）と演算子（`AND, OR, NOT, TRUE, FALSE`）はすべて**大文字**で記述してください。

4. **一貫性**: 1つの Rung（行）に書けるアクション（右側）は原則として1つです。

### 3.3 デバイス識別子

| デバイス | 記述例 | 説明 |
| --- | --- | --- |
| **ビット接点** | `X0`, `Y1`, `M10`, `T0`, `C0` | ON/OFF の状態。 |
| **ワード接点** | `D0`, `D100` | 数値データ（16bit整数）。 |
| **定数** | `100`, `TRUE`, `FALSE` | 数値または真理値。 |


### 3.4 演算機能（条件式とアクション）

#### 3.4.1 条件式（接点部）

論理演算子や比較演算子を組み合わせて記述します。

* **論理演算**: `AND`, `OR`, `NOT`
* **比較演算**: `==`, `!=`, `>`, `<`, `>=`, `<=`
* **優先順位**: `[ ]` で括ります。
* **例**: `"[ X0 AND [ M0 OR NOT X1 ] ] -- ( Y0 )"`

#### 3.4.2 アクション（出力・命令部）

条件が `TRUE` の時に実行される命令です。

* **コイル出力**: `(Y0)`, `(M10)`
* 条件成立でON、不成立でOFF。


* **数値代入・演算**: `(D0=100)`, `(D1=D0+1)`
* 四則演算（`+`, `-`, `*`, `/`）が使用可能。


* **タイマー (TON)**: `(TON {ID} {ms})`
* 入力が継続した時間分カウントアップし、タイムアップで接点（T）がON。
* 例: `"[ M0 ] --(TON T0 1000)"`


* **カウンタ (CTU)**: `(CTU {ID} {設定値})`
* 入力の立ち上がりでカウントし、設定値到達で接点（C）がON。
* 例: `"[ X1 ] --(CTU C0 5)"`


* **リセット (RES)**: `(RES {ID})`
* タイマーやカウンタの値を 0 にリセット。
* 例: `"[ X2 ] -- (RES C0)"`


### 3.5 記述例（逆引きリファレンス）

| 目的 | 推奨される記述例 |
| --- | --- |
| **自己保持回路** | `"[ [ X0 OR Y0 ] AND NOT X1 ] --(Y0)"` |
| **比較による判定** | `"[ D0 >= 500 ] --(M10)"` |
| **インクリメント** | `"[ X3 ] -- ( D0 = D0 + 1 )"` |
| **複数条件のタイマー** | `"[ X4 AND X5 ] -- ( TON T1 5000 )"` |
| **計算結果の格納** | `"[ TRUE ] -- ( D2 = [ D0 + D1 ] * 10 )"` |

---

## 4. デバイス設定仕様 (`device.yaml`)

`devicesim.py` は、PLCのビット入力（X）やデータレジスタ（D）の値を時間経過とともに自動変化させ、物理的な挙動やセンサー出力をシミュレートします。

### 4.1 設定ファイルの構造

```yaml
kind: device
version: "1.0"

device:
  name: dev_press        # デバイス識別名
  log_dir: logs          # ログ保存先
  plc:
    host: localhost      # 接続先PLCのホスト
    port: 15021          # 接続先PLCのModbusポート

  cycle_ms: 100          # 更新間隔（シミュレーションの分解能）

  signals:
    # ビット信号のシミュレーション
    power:
      type: discrete         # X (Discrete Input) を操作
      address: 0         # 書き込み先アドレス (X0)
      pattern:
        - value: true
          duration_ms: 500
        - value: false
          duration_ms: 10000

    # 数値データのシミュレーション
    motor_rpm:
      type: register     # D (Holding Register) を操作
      address: 0         # 書き込み先アドレス (D0)
      pattern:
        - value: 0
          duration_ms: 100
        - value: 100
          duration_ms: 300

```

### 4.2 信号タイプ詳細

#### 4.2.1. `discrete` 型（デジタル信号入力)

* **対象**: PLC内部メモリの X（外部入力）。
* **動作**: 内部的に write_coil を発行しますが、PLC側の特殊処理により Xメモリ（DI） が書き換わります。
* **用途**: センサー、スイッチ等の「PLCへの入力」をシミュレートする場合の推奨設定です。


#### 4.2.2. `coil` 型 (出力保持 / 内部フラグ操作)

* **対象**: PLC内部メモリの **Y**（出力）または **M**（内部フラグ）。
* **動作**: `pattern` に定義された `value` (true/false) を `duration_ms` の間保持し、リストの最後まで行くとループします。
* **用途**: PLC出力を外部から強制操作するデバック用。

#### 4.2.3. `register` 型 (アナログ信号)

* **対象**: PLC内部メモリの **D**（データレジスタ）。
* **動作**: `pattern` に定義された数値 (`value`) を指定時間保持します。リストをループ実行します。
* **用途**: モーターの回転数、温度センサーの変動、ワークの個数カウンターなど。

#### 4.2.4. `pulse` 型 (※サポート時)

* **動作**: 一度だけ指定時間ONになりOFFへ戻る。現在の実装で `coil` 型のパターンを一回に設定することでも代用可能です。


### 4.3 動作の仕組み

1. **接続**: 起動時に指定された `plc.host` および `port` へ Modbus TCP で接続します。
2. **ループ処理**: `cycle_ms` ごとに各 `signals` の経過時間を計算します。
3. **書き込み**: `duration_ms` が経過して値が切り替わるタイミングで、PLCの Modbus サーバーへ新しい値を送信します。

---

## 5. IODevice（中継・ブリッジ）仕様 (`iodevice.yaml`)

IODeviceは、複数のPLC間での信号転送（ブリッジ）や、特定の信号をトリガーとした数値演算（インクリメント等）を実行する中継ユニットです。

### 5.1 設定ファイルの構造

```yaml
kind: iodevice
version: "1.0"
name: "bridge_logic"      # サービス識別名
cycle_ms: 200             # 転送・監視の周期
log_dir: "logs"           # ログ保存先

connections:
  # 例1: ビット信号の転送（PLC1のY0 -> PLC2のX10）
  - name: "transfer_signal"
    trigger: {host: "localhost", port: 15020, address: 0, type: "coil"} 
    target:  {host: "localhost", port: 15030, address: 10, type: "discrete"}

  # 例2: 数値演算アクション（トリガーONでDレジスタを加算）
  - name: "count_up_logic"
    trigger: {host: "localhost", port: 15020, address: 1, type: "coil"}
    actions:
      - {host: "localhost", port: 15020, address: 100, type: "hr", op: "increment", value: 1}

```

### 5.2 主要機能

#### 5.2.1. 信号転送 (Bridge)

* **動作**: `trigger` で指定したアドレスの状態を監視し、変化があれば `target` で指定したアドレスへ値を書き込みます。
* **立ち上がり/立ち下がり**:
* `trigger` が OFF → ON になったとき、`target` を ON にします。
* `trigger` が ON → OFF になったとき、`target` を OFF にします。

* **用途**: プレス機の完了信号を隣のコンベアPLCの起動信号へ渡すなど、装置間連携に使用します。

* **type**: `discrete` の指定: 転送先が X領域の場合、この指定を行うことで「SIM_INJECT」機能を利用した確実な信号伝達が行われます。

#### 5.2.2. イベント駆動アクション (Actions)

`trigger` が **OFF → ON（立ち上がり）** になった瞬間のみ、指定された演算を実行します。

| 演算名 (`op`) | 内容 |
| --- | --- |
| `set` | `value` で指定した値を直接書き込む。 |
| `increment` / `add` | 現在値に `value` を加算する。 |
| `decrement` | 現在値から `value` を減算する（最小値は 0）。 |

#### 5.2.3. ハートビート監視 (Safety)

IODeviceは、自身が関与するすべてのPLCの生存状態を監視します。

* **監視先**: `connections` 内に登場するすべての `host:port`。
* **仕組み**: アドレス `10000` (SYS領域) を読み取り、値が **5秒以上** 変化しない場合、対象PLCが停止したと判断します。
* **異常検知**: ハートビート停止を検知すると、IODevice 自体も **FATALエラーとして強制停止** し、システムの連鎖的な不整合を防ぎます。

### 5.3 運用上のヒント

* **デッドロックの回避**: 双方向に `trigger` と `target` を設定する場合、ラダーロジック側の組み方によっては信号がループし続ける可能性があるため注意が必要です。
* **通信負荷**: `cycle_ms` を短くしすぎると、複数のPLCへのModbusクエリが重なり、ネットワーク負荷が高まります。通常は 100〜500ms 程度が推奨されます。


---

## 6. Orchestrator（システム管理・障害注入）

Orchestrator (`orchestrator.py`) は、独立した複数のプロセスを協調させ、一つの「生産ライン」として機能させるための司令塔です。

### 6.1 `orchestrator.yaml` の構成とサービスタイプ

Orchestrator は、`services` リストに定義された各プロセスを、役割に応じた `type` に基づいて管理します。

```yaml
kind: orchestrator
version: "1.0"
log:
  dir: "logs"

services:
  # --- 制御層 (PLC) ---
  - name: plc_press
    type: plc           # 制御ロジックを実行。異常終了時は自動再起動
    command: [plcsim.py]
    args: ["path/to/plc.yaml", "path/to/ladder.yaml"]
    ready_check:
      kind: modbus
      host: 127.0.0.1
      port: 15020

  # --- 神経層 (IODevice) ---
  - name: bridge_logic
    type: iodevice      # PLC間のデータ転送やイベント演算を担当
    command: [iodevicesim.py]
    args: ["path/to/bridge.yaml"]
    depends_on: [plc_press, plc_conv] # 接続先PLCが立ち上がってから起動

  # --- 物理層 (Device) ---
  - name: press_sensor
    type: device        # センサーやスイッチなどの物理的な時間変化を模倣
    command: [devicesim.py]
    args: ["path/to/device.yaml"]
    depends_on: [plc_press]

```

### 6.2 サービスタイプ別詳細仕様

| type | 役割 | 動作特性 |
| --- | --- | --- |
| **`plc`** | **制御の核** | プログラム実行中にクラッシュした場合、Orchestrator が即座に再起動を試み、制御の継続性を維持します（Self-healing）。 |
| **`iodevice`** | **連携の神経** | `depends_on` を利用して、複数のPLCがReady（Modbus接続可能）になった後に起動します。PLC間の同期やデータ集計を行います。 |
| **`device`** | **挙動の体** | PLCに対して入力(X)を送ったり出力(Y)を受け取ったりします。物理的なタイミング（搬送時間やスイッチのパルス幅）をシミュレートします。 |

### 6.3 依存関係と起動シーケンス (`depends_on`)

Orchestrator は `depends_on` プロパティを参照して、正しい順番でシステムを立ち上げます。

1. **PLC の起動**: 最初に `plc` サービスが起動し、Modbus サーバーとして待機を開始します。
2. **Ready チェック**: Orchestrator が各 PLC の Modbus ポートへの疎通を確認（Ready 状態）します。
3. **周辺機器の起動**: PLC が Ready になったことをトリガーに、`iodevice`（中継）や `device`（センサー等）が起動し、PLC への接続を開始します。

### 6.4 インタラクティブ CLI コマンド

Orchestrator 起動後は、専用の CLI プロンプトから以下の操作が可能です。

| コマンド | 引数 | 説明 |
| --- | --- | --- |
| **`status`** | なし | 全プロセスの PID、稼働状態、Ready 状態を表示。 |
| **`addr`** | `<PLC名>` | 指定したPLCのアドレス領域を表示。 |
| **`info`** | `<PLC名>` | 指定したPLCの全メモリ（X / Y / M / D）の状態を一覧表示。|
| **`log`** | なし | 対話型ログビューアを起動。 |
| **`chaos kill`** | `<name>` | プロセスを強制終了。`type: plc` の場合は即座に再起動。 |
| **`chaos stop`** | `<name>` | プロセスを停止し、自動再起動も無効化。 |
| **`chaos resume`** | `<name>` | `stop` したサービスを再度有効化し、再起動。 |
| **`chaos delay`** | `<name> <sec>` | **Modbus通信遅延を注入。** 指定秒数(0で解除)の応答遅延を発生させる。 |
| **`exit`** | なし | 全プロセスを安全に停止して終了。 |

#### 6.4.1 カオスエンジニアリング機能の詳細

#### 6.4.1.1 通信遅延注入 (`chaos delay`)

PLC内部のシステムレジスタ `10005` (Chaos Latency) を直接書き換えます。これにより、PLC内部の Modbus サーバーが応答を返す前に指定秒数ウェイトを入れるようになり、ネットワーク遅延や高負荷状態をシミュレートできます。

#### 6.4.2.2 プロセス修復 (Self-Healing)

Orchestrator は 1秒周期で各プロセスの生存を確認します。`type: plc` または `type: iodevice` と定義されたサービスが不意に終了した場合、設定された `ready_check` を再度通過するまで無限に再起動を試みます。

#### 6.4.3.3 連鎖停止

親となるプロセス（依存先）を `chaos stop` した場合、それに依存しているプロセスは通信エラー（またはIODeviceのハートビート停止）により安全にエラー停止、あるいは待機状態となる挙動をシミュレートします。

#### 6.4.2 可視化コマンドの動作原理

* `info` / `addr`:
  * Orchestrator 自体が Modbus クライアントとなり、バックグラウンドで対象 PLC の Modbus サーバーへクエリを発行します。
  * これにより、PLC のプロセスログを汚すことなく、リアルタイムな内部状態の監視が可能です。