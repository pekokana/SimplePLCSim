わかりました。現在の PLC シミュレータの実装内容から、YAML でラダーに記述できる命令・属性を整理してみます。また、最後に `END` 命令を置くことでシーケンスの終端を明示できます。

---

## 1️⃣ 現状サポートされている命令

| 命令タイプ        | YAML 表記          | 説明                                                                                       |
| ------------ | ---------------- | ---------------------------------------------------------------------------------------- |
| 通常ラダー        | `logic` + `coil` | 入力/内部リレーの論理式を評価して出力リレーに反映する。<br>例: `logic: X0 AND M0` / `coil: Y0`                       |
| タイマ (ONディレイ) | `type: TON`      | 入力が ON になってから指定時間後に出力を ON にする。<br>属性: `timer`(名前), `enable`(入力), `preset`(ms), `out`(出力) |
| カウンタ (CTU)   | `type: CTU`      | 入力の立上りをカウントし、プリセット値に達したら出力 ON。<br>属性: `counter`(名前), `input`(X), `preset`(回数), `out`(M)  |

---

## 2️⃣ 書き方例

### 通常ラダー

```yaml
- logic: X0 AND M0
  coil: Y0
```

### タイマ

```yaml
- type: TON
  timer: T0
  enable: X1
  preset: 2000  # 2秒
  out: Y1
```

### カウンタ

```yaml
- type: CTU
  counter: C0
  input: X2
  preset: 5
  out: M0
```

### シーケンス終了

```yaml
- type: END
```

> `END` はシーケンスの最後に置くことで、読みやすさと拡張性向上のために明示的に終端を示せます。現在の PLC コードに `type == "END"` を判定して何もしないように追加すれば対応可能です。

---

## 3️⃣ 今後拡張可能な命令（参考）

| 命令タイプ       | YAML 表記             | 説明                             |
| ----------- | ------------------- | ------------------------------ |
| タイマ OFFディレイ | `type: TOF`         | 出力 ON の入力が OFF になってから指定時間で OFF |
| リセットカウンタ    | `type: RES`         | 指定カウンタの値を 0 にリセット              |
| 内部計算レジスタ    | `type: ADD/SUB/MOV` | D レジスタ同士の演算や値転送                |
| 比較          | `type: CMP`         | D レジスタの値を比較してフラグに設定            |

---

💡 **ポイント**

* YAML で書く場合は `type` で命令を判別し、`logic + coil` 以外は必須属性を定義する
* ラダーの末尾は `END` を置くことで安全にシーケンスを終了
* 追加命令をサポートする場合は `PLC.scan()` 内の if-elif に処理を追加するだけで対応可能

---

もし希望であれば、次のステップとして **直感的ラダー文字列（例: `[X0 AND M0] --(Y0)`) を YAML に変換する parser** を作って、現行 PLC に読み込ませるサンプルも作れます。

作りますか？


-----

はい、実際の PLC でも内部計算や比較の命令はよく使われます。これは「単純な ON/OFF 制御だけではなく、値に基づく判断や演算をラダー内で行う必要がある」場合のためです。具体的には以下のようなものがあります。

---

### 1️⃣ 内部計算系

| 命令    | 説明        | 例              |
| ----- | --------- | -------------- |
| `ADD` | レジスタ同士の加算 | `D0 = D1 + D2` |
| `SUB` | 減算        | `D0 = D1 - D2` |
| `MUL` | 乗算        | `D0 = D1 * D2` |
| `DIV` | 除算        | `D0 = D1 / D2` |
| `MOV` | 値の転送      | `D1 → D0`      |

※ `D` レジスタなどに整数値を保持し、ラダー内で計算可能です。

---

### 2️⃣ 比較系

| 命令       | 説明       | 例                  |
| -------- | -------- | ------------------ |
| `CMP_EQ` | 等しいか比較   | `D0 == D1 → M0 ON` |
| `CMP_NE` | 等しくないか比較 | `D0 != D1 → M1 ON` |
| `CMP_GT` | 大なり      | `D0 > D1 → M2 ON`  |
| `CMP_LT` | 小なり      | `D0 < D1 → M3 ON`  |
| `CMP_GE` | 以上       | `D0 >= D1 → M4 ON` |
| `CMP_LE` | 以下       | `D0 <= D1 → M5 ON` |

---

### 3️⃣ 使われる場面

* モーターやポンプの回転数、温度、圧力などアナログ値を扱う場合
* 複雑なロジックで条件分岐を行いたい場合
* タイマやカウンタの値に応じた制御

---

💡 **ポイント**

* デジタル入力だけでなく、数値レジスタを使った計算や比較が PLC の標準機能に含まれている
* SCADA や装置シミュレーションで「値に基づく判断」を再現する場合には、内部計算・比較命令のシミュレーションも必要

---

もし希望であれば、今作っている Python PLC シミュレーターに **ADD / CMP などの演算系命令** を追加するサンプルも作れます。

作りますか？
